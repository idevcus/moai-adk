# @DATA:TAG-MODEL "16-Core TAG Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú Îç∞Ïù¥ÌÑ∞ Î™®Îç∏"

> **SPEC-002 Phase 1 Design**: ÏΩîÎìú TAG Í¥ÄÎ¶¨ ÏãúÏä§ÌÖúÏùò ÌïµÏã¨ Îç∞Ïù¥ÌÑ∞ Î™®Îç∏ Î∞è ÏïÑÌÇ§ÌÖçÏ≤ò ÏÑ§Í≥Ñ

## üìä Í∞úÏöî

Î≥∏ Î¨∏ÏÑúÎäî SPEC-002Ïùò Phase 1 ÏÑ§Í≥ÑÎ°ú, 16-Core TAG Í¥ÄÎ¶¨ ÏãúÏä§ÌÖúÏùò Îç∞Ïù¥ÌÑ∞ Î™®Îç∏, ÌîåÎ°úÏö∞ ÏÑ§Í≥Ñ, Ï†ÄÏû• Ï†ÑÎûµ Î∞è ÏÑ±Îä• Í≥†Î†§ÏÇ¨Ìï≠ÏùÑ Îã§Î£πÎãàÎã§.

## üèóÔ∏è ÌïµÏã¨ ÏóîÌã∞Ìã∞ Î™®Îç∏

### 1. Tag ÏóîÌã∞Ìã∞

```python
@dataclass
class Tag:
    """16-Core TAG ÏãúÏä§ÌÖúÏùò ÌïµÏã¨ ÏóîÌã∞Ìã∞"""

    # Í∏∞Î≥∏ ÏãùÎ≥Ñ Ï†ïÎ≥¥
    id: str  # @REQ:CODE-TAG-002 ÌòïÏãù
    category: TagCategory  # SPEC, STEERING, IMPLEMENTATION, QUALITY
    type: TagType  # REQ, DESIGN, TASK, etc.
    topic: str  # CODE-TAG, USER-AUTH, etc.
    sequence: Optional[str]  # 002, 001, etc.

    # Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
    description: str
    created_at: datetime
    updated_at: datetime
    status: TagStatus  # active, draft, deprecated
    priority: Optional[int]  # 1-5 Ïö∞ÏÑ†ÏàúÏúÑ

    # ÏúÑÏπò Ï†ïÎ≥¥
    file_path: str
    line_number: int
    context: Optional[str]  # Ï£ºÎ≥Ä ÏΩîÎìú Ïª®ÌÖçÏä§Ìä∏

    # Ï∂îÏ†ÅÏÑ± Ï†ïÎ≥¥
    parent_tags: List[str]  # ÏÉÅÏúÑ TAG Ï∞∏Ï°∞
    child_tags: List[str]   # ÌïòÏúÑ TAG Ï∞∏Ï°∞
    related_tags: List[str] # Ïó∞Í¥Ä TAG Ï∞∏Ï°∞

    # ÌíàÏßà Ï†ïÎ≥¥
    auto_generated: bool = False
    confidence_score: float = 1.0  # 0.0-1.0
    validation_status: ValidationStatus = ValidationStatus.PENDING

    # Î≥ÄÍ≤Ω Ï∂îÏ†Å
    created_by: Optional[str]
    last_modified_by: Optional[str]
    change_reason: Optional[str]
```

### 2. TagIndex ÏóîÌã∞Ìã∞

```python
@dataclass
class TagIndex:
    """TAG Ïù∏Îç±Ïä§ Í¥ÄÎ¶¨ ÏóîÌã∞Ìã∞"""

    # Ïù∏Îç±Ïä§ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
    version: str  # 16-core
    created_at: datetime
    last_updated: datetime
    total_tags: int

    # Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ ÌÜµÍ≥Ñ
    category_stats: Dict[TagCategory, int]
    status_stats: Dict[TagStatus, int]

    # Ïù∏Îç±Ïä§ Îç∞Ïù¥ÌÑ∞
    tags: Dict[str, Tag]  # tag_id -> Tag
    file_mappings: Dict[str, List[str]]  # file_path -> [tag_ids]

    # Í¥ÄÍ≥Ñ Í∑∏ÎûòÌîÑ
    relationships: Dict[str, List[TagRelationship]]

    # ÏÑ±Îä• Î©îÌä∏Î¶≠
    index_size_bytes: int
    last_scan_duration_ms: int
    last_validation_duration_ms: int
```

### 3. FileMapping ÏóîÌã∞Ìã∞

```python
@dataclass
class FileMapping:
    """ÌååÏùºÍ≥º TAG Í∞ÑÏùò Îß§Ìïë Ï†ïÎ≥¥"""

    # ÌååÏùº Ï†ïÎ≥¥
    file_path: str
    file_hash: str  # SHA-256 hash
    file_size_bytes: int
    last_modified: datetime

    # TAG Ï†ïÎ≥¥
    tags: List[str]  # TAG IDs in this file
    tag_count: int

    # ÌååÏùº Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
    language: str  # python, javascript, etc.
    encoding: str  # utf-8
    line_count: int
    function_count: int
    class_count: int
    complexity_score: float

    # ÌååÏã± Ï†ïÎ≥¥
    parser_used: ParserType  # libcst, tree_sitter, ast
    parse_time_ms: int
    syntax_errors: List[str]
    warnings: List[str]

    # ÏÉÅÌÉú Ï∂îÏ†Å
    scan_status: ScanStatus  # success, error, skipped
    last_scanned: datetime
    scan_duration_ms: int
```

### 4. ValidationResult ÏóîÌã∞Ìã∞

```python
@dataclass
class ValidationResult:
    """TAG Í≤ÄÏ¶ù Í≤∞Í≥º"""

    # Í≤ÄÏ¶ù ÏÑ∏ÏÖò Ï†ïÎ≥¥
    validation_id: str  # UUID
    timestamp: datetime
    validation_type: ValidationType  # format, consistency, traceability

    # Í≤ÄÏ¶ù ÎåÄÏÉÅ
    target_tags: List[str]
    target_files: List[str]
    scope: ValidationScope  # project, directory, file

    # Í≤ÄÏ¶ù Í≤∞Í≥º
    status: ValidationStatus  # passed, failed, warning
    total_checks: int
    passed_checks: int
    failed_checks: int
    warnings: int

    # ÏÉÅÏÑ∏ Í≤∞Í≥º
    issues: List[ValidationIssue]
    suggestions: List[str]
    auto_fixes_applied: List[str]

    # ÏÑ±Îä• Ï†ïÎ≥¥
    duration_ms: int
    memory_usage_mb: float
    processed_items: int
```

## üîÑ Îç∞Ïù¥ÌÑ∞ ÌîåÎ°úÏö∞ ÏÑ§Í≥Ñ

### 1. Scan ‚Üí Validate ‚Üí Index ‚Üí Monitor ÌååÏù¥ÌîÑÎùºÏù∏

```mermaid
graph LR
    A[File Changes] --> B[Scanner]
    B --> C[Parser<br/>LibCST/Tree-sitter]
    C --> D[TAG Extractor]
    D --> E[Validator]
    E --> F{Valid?}
    F -->|Yes| G[Indexer]
    F -->|No| H[Auto-Repair]
    H --> E
    G --> I[JSON Store]
    G --> J[SQLite Store]
    I --> K[Monitor]
    J --> K
    K --> L[Dashboard]
```

### 2. Ïã§ÏãúÍ∞Ñ Î≥ÄÍ≤Ω Í∞êÏßÄ ÌîåÎ°úÏö∞

```python
class ChangeDetectionFlow:
    """Ïã§ÏãúÍ∞Ñ ÌååÏùº Î≥ÄÍ≤Ω Í∞êÏßÄ Î∞è Ï≤òÎ¶¨"""

    def __init__(self):
        self.file_watcher = WatchdogObserver()
        self.change_queue = asyncio.Queue()
        self.batch_processor = BatchProcessor()

    async def process_file_change(self, event: FileSystemEvent):
        """ÌååÏùº Î≥ÄÍ≤Ω Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨"""
        if event.src_path.endswith('.py'):
            change = FileChange(
                file_path=event.src_path,
                change_type=event.event_type,
                timestamp=datetime.now()
            )
            await self.change_queue.put(change)

    async def batch_process_changes(self):
        """Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Î∞∞Ïπò Ï≤òÎ¶¨"""
        changes = await self.batch_processor.collect_changes(
            timeout_ms=1000,  # 1Ï¥à ÎåÄÍ∏∞
            max_batch_size=50
        )

        # Ïä§Ï∫î ‚Üí Í≤ÄÏ¶ù ‚Üí Ïù∏Îç±Ïã± ÌååÏù¥ÌîÑÎùºÏù∏ Ïã§Ìñâ
        scan_results = await self.scanner.scan_files(changes)
        validation_results = await self.validator.validate_tags(scan_results)
        await self.indexer.update_index(validation_results)

        # Î™®ÎãàÌÑ∞ÎßÅ Ïù¥Î≤§Ìä∏ Î∞úÏÉù
        await self.monitor.emit_change_event(changes, validation_results)
```

### 3. Í≤ÄÏ¶ù Ï≤¥Ïù∏ ÌîåÎ°úÏö∞

```python
class ValidationChain:
    """TAG Í≤ÄÏ¶ù Ï≤¥Ïù∏ Ï≤òÎ¶¨"""

    validators = [
        FormatValidator(),      # TAG ÌòïÏãù Í≤ÄÏ¶ù
        NamingValidator(),      # Î™ÖÎ™Ö Í∑úÏπô Í≤ÄÏ¶ù
        ConsistencyValidator(), # ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù
        TraceabilityValidator(), # Ï∂îÏ†ÅÏÑ± Í≤ÄÏ¶ù
        DuplicateValidator(),   # Ï§ëÎ≥µ Í≤ÄÏ¶ù
        OrphanValidator()       # Í≥†ÏïÑ TAG Í≤ÄÏ¶ù
    ]

    async def validate(self, tags: List[Tag]) -> ValidationResult:
        """Í≤ÄÏ¶ù Ï≤¥Ïù∏ Ïã§Ìñâ"""
        result = ValidationResult()

        for validator in self.validators:
            validator_result = await validator.validate(tags)
            result.merge(validator_result)

            # Ïã¨Í∞ÅÌïú Ïò§Î•ò Ïãú Ï≤¥Ïù∏ Ï§ëÎã®
            if validator_result.has_critical_errors():
                break

        return result
```

## üíæ Ï†ÄÏû• Ï†ÑÎûµ - JSON + SQLite ÌïòÏù¥Î∏åÎ¶¨Îìú Ï†ëÍ∑º

### 1. JSON Ï†ÄÏû•ÏÜå (Î©îÏù∏ Ïù∏Îç±Ïä§)

```json
{
  "meta": {
    "version": "16-core",
    "created": "2025-09-18T10:00:00Z",
    "last_updated": "2025-09-18T15:30:00Z",
    "total_tags": 1247,
    "index_size_bytes": 2048576
  },
  "categories": {
    "SPEC": {
      "description": "Î¨∏ÏÑú Ï∂îÏ†Å - ÌïÑÏàò",
      "tags": ["REQ", "DESIGN", "TASK"],
      "count": 425
    },
    "STEERING": {
      "description": "ÏõêÏπô Ï∂îÏ†Å - ÌïÑÏàò",
      "tags": ["VISION", "STRUCT", "TECH", "ADR"],
      "count": 156
    },
    "IMPLEMENTATION": {
      "description": "ÏΩîÎìú Ï∂îÏ†Å - ÌïÑÏàò",
      "tags": ["FEATURE", "API", "TEST", "DATA"],
      "count": 498
    },
    "QUALITY": {
      "description": "ÌíàÏßà Ï∂îÏ†Å - ÏÑ†ÌÉù",
      "tags": ["PERF", "SEC", "DEBT", "TODO"],
      "count": 168
    }
  },
  "active_tags": {
    "@REQ:CODE-TAG-002": {
      "category": "SPEC",
      "topic": "CODE-TAG",
      "id": "002",
      "description": "src/moai_adk ÏΩîÎìúÎ≤†Ïù¥Ïä§ Ï†ÑÏ≤¥Ïóê 16-Core TAG ÏãúÏä§ÌÖú Ï†ÅÏö©",
      "file": ".moai/specs/SPEC-002/spec.md",
      "line": 3,
      "created": "2025-09-18T10:00:00Z",
      "updated": "2025-09-18T15:30:00Z",
      "status": "active",
      "priority": 2,
      "relationships": {
        "implements": ["@VISION:MOAI-ADK"],
        "references": ["@TECH:MOAI-ADK"],
        "traces_to": ["@TASK:TAG-SCAN-001", "@TASK:TAG-VALIDATE-001"]
      }
    }
  },
  "file_mappings": {
    "src/moai_adk/core/engine.py": {
      "tags": ["@FEATURE:ENGINE-CORE", "@API:GET-STATUS"],
      "last_scanned": "2025-09-18T15:25:00Z",
      "hash": "a1b2c3d4e5f6...",
      "size_bytes": 1024,
      "line_count": 45,
      "complexity": 3.2
    }
  },
  "statistics": {
    "by_category": {
      "SPEC": 425,
      "STEERING": 156,
      "IMPLEMENTATION": 498,
      "QUALITY": 168
    },
    "by_status": {
      "active": 1180,
      "draft": 45,
      "deprecated": 22
    },
    "health_metrics": {
      "orphaned_tags": 12,
      "duplicate_tags": 3,
      "broken_references": 5,
      "health_score": 0.94
    }
  }
}
```

### 2. SQLite Ï†ÄÏû•ÏÜå (Í¥ÄÍ≥ÑÌòï Îç∞Ïù¥ÌÑ∞)

```sql
-- ÌÖåÏù¥Î∏î Ïä§ÌÇ§Îßà
CREATE TABLE tags (
    id TEXT PRIMARY KEY,
    category TEXT NOT NULL,
    type TEXT NOT NULL,
    topic TEXT NOT NULL,
    sequence TEXT,
    description TEXT NOT NULL,
    file_path TEXT NOT NULL,
    line_number INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status TEXT DEFAULT 'active',
    priority INTEGER,
    auto_generated BOOLEAN DEFAULT FALSE,
    confidence_score REAL DEFAULT 1.0,
    created_by TEXT,
    last_modified_by TEXT
);

CREATE TABLE tag_relationships (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    source_tag TEXT NOT NULL,
    target_tag TEXT NOT NULL,
    relationship_type TEXT NOT NULL, -- implements, references, traces_to
    strength REAL DEFAULT 1.0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (source_tag) REFERENCES tags(id),
    FOREIGN KEY (target_tag) REFERENCES tags(id)
);

CREATE TABLE file_mappings (
    file_path TEXT PRIMARY KEY,
    file_hash TEXT NOT NULL,
    file_size_bytes INTEGER,
    last_modified TIMESTAMP,
    last_scanned TIMESTAMP,
    scan_duration_ms INTEGER,
    tag_count INTEGER DEFAULT 0,
    language TEXT,
    line_count INTEGER,
    complexity_score REAL
);

CREATE TABLE validation_history (
    id TEXT PRIMARY KEY,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    validation_type TEXT NOT NULL,
    status TEXT NOT NULL,
    total_checks INTEGER,
    passed_checks INTEGER,
    failed_checks INTEGER,
    warnings INTEGER,
    duration_ms INTEGER
);

-- Ïù∏Îç±Ïä§ ÏÉùÏÑ±
CREATE INDEX idx_tags_category ON tags(category);
CREATE INDEX idx_tags_type ON tags(type);
CREATE INDEX idx_tags_status ON tags(status);
CREATE INDEX idx_tags_file_path ON tags(file_path);
CREATE INDEX idx_relationships_source ON tag_relationships(source_tag);
CREATE INDEX idx_relationships_target ON tag_relationships(target_tag);
CREATE INDEX idx_file_mappings_last_scanned ON file_mappings(last_scanned);
```

### 3. ÌïòÏù¥Î∏åÎ¶¨Îìú Ï†ëÍ∑ºÎ≤ïÏùò Ïû•Ï†ê

| Ï†ÄÏû•ÏÜå | Ïö©ÎèÑ | Ïû•Ï†ê | ÏÑ±Îä• ÌäπÏÑ± |
|--------|------|------|-----------|
| **JSON** | Î©îÏù∏ Ïù∏Îç±Ïä§, Îπ†Î•∏ ÏùΩÍ∏∞ | Îã®ÏàúÌï®, Í∞ÄÎèÖÏÑ±, Î∞±ÏóÖ Ïö©Ïù¥ | ÏùΩÍ∏∞: O(1), Ïì∞Í∏∞: O(n) |
| **SQLite** | Î≥µÏû°Ìïú ÏøºÎ¶¨, Í¥ÄÍ≥ÑÌòï Îç∞Ïù¥ÌÑ∞ | Í∞ïÎ†•Ìïú ÏøºÎ¶¨, Ìä∏ÎûúÏû≠ÏÖò, Î¨¥Í≤∞ÏÑ± | ÏùΩÍ∏∞: O(log n), Ïì∞Í∏∞: O(log n) |

## ‚ö° ÏÑ±Îä• Í≥†Î†§ÏÇ¨Ìï≠

### 1. Î™©Ìëú ÏÑ±Îä• ÏßÄÌëú

| Î©îÌä∏Î¶≠ | Î™©Ìëú | ÌòÑÏû¨ Í∏∞Ï§Ä |
|--------|------|-----------|
| **Ïä§Ï∫î ÏÜçÎèÑ** | 5Ï¥à/1000ÌååÏùº | 1000 LOC Python ÌååÏùº Í∏∞Ï§Ä |
| **Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ** | <500MB | 10,000 TAG ÌîÑÎ°úÏ†ùÌä∏ Í∏∞Ï§Ä |
| **Ïù∏Îç±Ïä§ ÏóÖÎç∞Ïù¥Ìä∏** | <100ms | Îã®Ïùº ÌååÏùº Î≥ÄÍ≤Ω Í∏∞Ï§Ä |
| **Í≤ÄÏÉâ ÏùëÎãµ** | <50ms | Îã®Ïàú ÌÖçÏä§Ìä∏ Í≤ÄÏÉâ Í∏∞Ï§Ä |
| **Í≤ÄÏ¶ù ÏÜçÎèÑ** | <10Ï¥à | Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏ Í≤ÄÏ¶ù Í∏∞Ï§Ä |

### 2. LibCST + Tree-sitter ÌïòÏù¥Î∏åÎ¶¨Îìú ÌååÏã± Ï†ÑÎûµ

```python
class HybridParser:
    """LibCSTÏôÄ Tree-sitterÎ•º Ï°∞Ìï©Ìïú ÌïòÏù¥Î∏åÎ¶¨Îìú ÌååÏÑú"""

    def __init__(self):
        self.libcst_parser = LibCSTParser()  # Ï†ïÌôïÌïú Python AST
        self.tree_sitter_parser = TreeSitterParser()  # Îπ†Î•∏ Íµ¨Î¨∏ Î∂ÑÏÑù

    async def parse_file(self, file_path: str) -> ParseResult:
        """ÌååÏùº ÌÅ¨Í∏∞ÏôÄ Î≥µÏû°ÎèÑÏóê Îî∞Î•∏ Ï†ÅÏùëÌòï ÌååÏã±"""
        file_info = await self.analyze_file(file_path)

        if file_info.size_bytes > 100_000 or file_info.complexity > 10:
            # ÌÅ∞ ÌååÏùº: Tree-sitterÎ°ú Îπ†Î•∏ ÌååÏã±
            return await self.tree_sitter_parser.parse(file_path)
        else:
            # ÏûëÏùÄ ÌååÏùº: LibCSTÎ°ú Ï†ïÌôïÌïú ÌååÏã±
            return await self.libcst_parser.parse(file_path)

    async def extract_tags(self, parse_result: ParseResult) -> List[Tag]:
        """ÌååÏã± Í≤∞Í≥ºÏóêÏÑú TAG Ï∂îÏ∂ú"""
        visitor = TagExtractionVisitor()

        if parse_result.parser_type == ParserType.LIBCST:
            # LibCST AST ÏàúÌöå
            parse_result.tree.visit(visitor)
        else:
            # Tree-sitter ÎÖ∏Îìú ÏàúÌöå
            visitor.visit_tree_sitter(parse_result.tree)

        return visitor.extracted_tags
```

### 3. orjsonÏùÑ ÌôúÏö©Ìïú Í≥†ÏÑ±Îä• JSON Ï≤òÎ¶¨

```python
import orjson
from typing import Any, Dict

class HighPerformanceJSONStore:
    """orjson Í∏∞Î∞ò Í≥†ÏÑ±Îä• JSON Ï†ÄÏû•ÏÜå"""

    def __init__(self, file_path: str):
        self.file_path = file_path
        self._cache: Optional[Dict[str, Any]] = None
        self._cache_timestamp: Optional[float] = None

    async def load(self) -> Dict[str, Any]:
        """ÎπÑÎèôÍ∏∞ JSON Î°úÎìú (Ï∫êÏã± Ìè¨Ìï®)"""
        current_time = time.time()

        if (self._cache is None or
            current_time - self._cache_timestamp > 60):  # 1Î∂Ñ Ï∫êÏãú

            async with aiofiles.open(self.file_path, 'rb') as f:
                content = await f.read()
                self._cache = orjson.loads(content)
                self._cache_timestamp = current_time

        return self._cache

    async def save(self, data: Dict[str, Any]) -> None:
        """ÎπÑÎèôÍ∏∞ JSON Ï†ÄÏû• (ÏµúÏ†ÅÌôîÎêú ÏßÅÎ†¨Ìôî)"""
        serialized = orjson.dumps(
            data,
            option=orjson.OPT_INDENT_2 | orjson.OPT_SORT_KEYS
        )

        async with aiofiles.open(self.file_path, 'wb') as f:
            await f.write(serialized)

        # Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏
        self._cache = data
        self._cache_timestamp = time.time()
```

### 4. WatchdogÎ•º ÌôúÏö©Ìïú ÌååÏùº Î™®ÎãàÌÑ∞ÎßÅ

```python
import asyncio
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class TagFileWatcher(FileSystemEventHandler):
    """Ïã§ÏãúÍ∞Ñ ÌååÏùº Î≥ÄÍ≤Ω Î™®ÎãàÌÑ∞ÎßÅ"""

    def __init__(self, change_handler):
        self.change_handler = change_handler
        self.change_buffer = {}
        self.buffer_timeout = 1.0  # 1Ï¥à Î≤ÑÌçºÎßÅ

    def on_modified(self, event):
        if not event.is_directory and event.src_path.endswith('.py'):
            # Î≤ÑÌçºÎßÅÏúºÎ°ú Ïó∞ÏÜç Î≥ÄÍ≤Ω ÌÜµÌï©
            self.change_buffer[event.src_path] = time.time()
            asyncio.create_task(self._process_buffered_changes())

    async def _process_buffered_changes(self):
        """Î≤ÑÌçºÎßÅÎêú Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï≤òÎ¶¨"""
        await asyncio.sleep(self.buffer_timeout)

        current_time = time.time()
        changes_to_process = []

        for file_path, change_time in list(self.change_buffer.items()):
            if current_time - change_time >= self.buffer_timeout:
                changes_to_process.append(file_path)
                del self.change_buffer[file_path]

        if changes_to_process:
            await self.change_handler.process_file_changes(changes_to_process)
```

## üîí Î≥¥Ïïà Î∞è Î¨¥Í≤∞ÏÑ±

### 1. ÏûÖÎ†• Í≤ÄÏ¶ù Î∞è Ï†ïÍ∑úÌôî

```python
class TagInputValidator:
    """TAG ÏûÖÎ†• Í≤ÄÏ¶ù Î∞è Ï†ïÍ∑úÌôî"""

    TAG_PATTERN = re.compile(
        r'^@(REQ|DESIGN|TASK|VISION|STRUCT|TECH|ADR|FEATURE|API|TEST|DATA|PERF|SEC|DEBT|TODO):'
        r'[A-Z0-9_-]+(?:-\d{3})?$'
    )

    def validate_tag_format(self, tag: str) -> ValidationResult:
        """TAG ÌòïÏãù Í≤ÄÏ¶ù"""
        if not isinstance(tag, str):
            return ValidationResult.error("TAG must be string")

        if len(tag) > 100:
            return ValidationResult.error("TAG too long (max 100 chars)")

        if not self.TAG_PATTERN.match(tag):
            return ValidationResult.error(f"Invalid TAG format: {tag}")

        return ValidationResult.success()

    def sanitize_description(self, description: str) -> str:
        """ÏÑ§Î™Ö Î¨∏ÏûêÏó¥ Ï†ïÍ∑úÌôî"""
        # HTML ÌÉúÍ∑∏ Ï†úÍ±∞
        description = re.sub(r'<[^>]*>', '', description)

        # ÌäπÏàò Î¨∏Ïûê Ïù¥Ïä§ÏºÄÏù¥Ìïë
        description = html.escape(description)

        # Í∏∏Ïù¥ Ï†úÌïú
        if len(description) > 500:
            description = description[:497] + "..."

        return description.strip()
```

### 2. Ï†ëÍ∑º Ï†úÏñ¥ Î∞è Í∞êÏÇ¨ Î°úÍπÖ

```python
class TagAccessControl:
    """TAG ÏãúÏä§ÌÖú Ï†ëÍ∑º Ï†úÏñ¥"""

    def __init__(self):
        self.audit_logger = AuditLogger()

    def check_permission(self, user: str, action: str, resource: str) -> bool:
        """Í∂åÌïú Í≤ÄÏÇ¨"""
        permissions = self.get_user_permissions(user)

        required_permission = f"{action}:{resource}"
        has_permission = required_permission in permissions

        # Í∞êÏÇ¨ Î°úÍ∑∏ Í∏∞Î°ù
        self.audit_logger.log_access_attempt(
            user=user,
            action=action,
            resource=resource,
            granted=has_permission,
            timestamp=datetime.now()
        )

        return has_permission

    @contextmanager
    def audit_context(self, user: str, operation: str):
        """Í∞êÏÇ¨ Ïª®ÌÖçÏä§Ìä∏ Îß§ÎãàÏ†Ä"""
        operation_id = str(uuid.uuid4())
        start_time = time.time()

        self.audit_logger.log_operation_start(
            operation_id=operation_id,
            user=user,
            operation=operation,
            timestamp=datetime.now()
        )

        try:
            yield operation_id
            duration = time.time() - start_time
            self.audit_logger.log_operation_success(
                operation_id=operation_id,
                duration_ms=int(duration * 1000)
            )
        except Exception as e:
            duration = time.time() - start_time
            self.audit_logger.log_operation_failure(
                operation_id=operation_id,
                error=str(e),
                duration_ms=int(duration * 1000)
            )
            raise
```

## üìà Î™®ÎãàÌÑ∞ÎßÅ Î∞è Í¥ÄÏ∞∞Í∞ÄÎä•ÏÑ±

### 1. Íµ¨Ï°∞ÌôîÎêú Î°úÍπÖ

```python
import structlog

# Î°úÍ±∞ ÏÑ§Ï†ï
logger = structlog.get_logger()

class TagSystemLogger:
    """TAG ÏãúÏä§ÌÖú Ï†ÑÏö© Î°úÍ±∞"""

    def __init__(self):
        self.logger = logger.bind(component="tag-system")

    def log_scan_start(self, files: List[str], user: str):
        """Ïä§Ï∫î ÏãúÏûë Î°úÍ∑∏"""
        self.logger.info(
            "tag_scan_started",
            file_count=len(files),
            user=user,
            operation_id=str(uuid.uuid4())
        )

    def log_validation_result(self, result: ValidationResult):
        """Í≤ÄÏ¶ù Í≤∞Í≥º Î°úÍ∑∏"""
        self.logger.info(
            "tag_validation_completed",
            validation_id=result.validation_id,
            status=result.status.value,
            total_checks=result.total_checks,
            failed_checks=result.failed_checks,
            duration_ms=result.duration_ms
        )

    def log_performance_metric(self, operation: str, duration_ms: int,
                             memory_mb: float, items_processed: int):
        """ÏÑ±Îä• Î©îÌä∏Î¶≠ Î°úÍ∑∏"""
        self.logger.info(
            "performance_metric",
            operation=operation,
            duration_ms=duration_ms,
            memory_mb=memory_mb,
            items_processed=items_processed,
            throughput=items_processed / (duration_ms / 1000) if duration_ms > 0 else 0
        )
```

### 2. Î©îÌä∏Î¶≠ ÏàòÏßë

```python
from prometheus_client import Counter, Histogram, Gauge

class TagSystemMetrics:
    """Prometheus Î©îÌä∏Î¶≠ ÏàòÏßë"""

    def __init__(self):
        # Ïπ¥Ïö¥ÌÑ∞
        self.scans_total = Counter('tag_scans_total', 'Total TAG scans')
        self.validations_total = Counter('tag_validations_total', 'Total validations')
        self.errors_total = Counter('tag_errors_total', 'Total errors', ['error_type'])

        # ÌûàÏä§ÌÜ†Í∑∏Îû® (ÏùëÎãµÏãúÍ∞Ñ)
        self.scan_duration = Histogram('tag_scan_duration_seconds', 'Scan duration')
        self.validation_duration = Histogram('tag_validation_duration_seconds', 'Validation duration')

        # Í≤åÏù¥ÏßÄ (ÌòÑÏû¨ ÏÉÅÌÉú)
        self.active_tags = Gauge('tag_active_total', 'Active TAGs')
        self.index_size_bytes = Gauge('tag_index_size_bytes', 'Index size in bytes')
        self.memory_usage = Gauge('tag_system_memory_bytes', 'Memory usage')

    def record_scan(self, duration_seconds: float, tags_found: int):
        """Ïä§Ï∫î Î©îÌä∏Î¶≠ Í∏∞Î°ù"""
        self.scans_total.inc()
        self.scan_duration.observe(duration_seconds)
        self.active_tags.set(tags_found)

    def record_error(self, error_type: str):
        """ÏóêÎü¨ Î©îÌä∏Î¶≠ Í∏∞Î°ù"""
        self.errors_total.labels(error_type=error_type).inc()
```

## üöÄ Constitution Ï§ÄÏàò Î∞è ÏïÑÌÇ§ÌÖçÏ≤ò Í≤∞Ï†ï

### 1. Î™®Îìà ÌÜµÌï© (4 ‚Üí 3)

ConstitutionÏùò Simplicity ÏõêÏπôÏóê Îî∞Îùº Î™®ÎìàÏùÑ ÌÜµÌï©:

```python
# Í∏∞Ï°¥ 4Í∞ú Î™®Îìà
# - tag-scanner.py
# - tag-validator.py
# - tag-indexer.py
# - tag-repair.py

# ÌÜµÌï©Îêú 3Í∞ú Î™®Îìà
class CoreEngine:
    """ÌïµÏã¨ ÏóîÏßÑ: Ïä§Ï∫î + Í≤ÄÏ¶ù ÌÜµÌï©"""
    scanner: TagScanner
    validator: TagValidator

class IntegrationModule:
    """ÌÜµÌï© Î™®Îìà: Ïù∏Îç±Ïã± + Git Ïó∞Îèô"""
    indexer: TagIndexer
    git_integration: GitIntegration

class MonitoringModule:
    """Î™®ÎãàÌÑ∞ÎßÅ Î™®Îìà: ÎåÄÏãúÎ≥¥Îìú + Î≥µÍµ¨"""
    monitor: TagMonitor
    auto_repair: TagRepair
```

### 2. TDD Ï§ÄÎπÑ ÏÑ§Í≥Ñ

Î™®Îì† Ïª¥Ìè¨ÎÑåÌä∏Ïóê Î™ÖÌôïÌïú Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ÏôÄ ÌÖåÏä§Ìä∏ Í∞ÄÎä•Ìïú Íµ¨Ï°∞:

```python
# Ï∂îÏÉÅ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
class TagScannerInterface(ABC):
    @abstractmethod
    async def scan_files(self, file_paths: List[str]) -> ScanResult: ...

    @abstractmethod
    async def suggest_tags(self, file_content: str) -> List[Tag]: ...

# Íµ¨ÌòÑ ÌÅ¥ÎûòÏä§
class LibCSTTagScanner(TagScannerInterface):
    async def scan_files(self, file_paths: List[str]) -> ScanResult:
        # Íµ¨ÌòÑ
        pass

# ÌÖåÏä§Ìä∏ Í∞ÄÎä•Ìïú Íµ¨Ï°∞
class TestableTagScanner(TagScannerInterface):
    def __init__(self, mock_responses: Dict[str, ScanResult]):
        self.mock_responses = mock_responses

    async def scan_files(self, file_paths: List[str]) -> ScanResult:
        return self.mock_responses.get(file_paths[0], ScanResult.empty())
```

### 3. Íµ¨Ï°∞ÌôîÎêú Î°úÍπÖ Î∞è Í¥ÄÏ∞∞Í∞ÄÎä•ÏÑ±

Î™®Îì† Ïª¥Ìè¨ÎÑåÌä∏Ïóê ÏùºÍ¥ÄÎêú Î°úÍπÖ Ï†ÅÏö©:

```python
class ObservableComponent:
    """Í¥ÄÏ∞∞ Í∞ÄÎä•Ìïú Ïª¥Ìè¨ÎÑåÌä∏ Î≤†Ïù¥Ïä§ ÌÅ¥ÎûòÏä§"""

    def __init__(self, component_name: str):
        self.logger = structlog.get_logger().bind(component=component_name)
        self.metrics = ComponentMetrics(component_name)

    @contextmanager
    def operation_context(self, operation: str, **kwargs):
        """ÏûëÏóÖ Ïª®ÌÖçÏä§Ìä∏ with Î°úÍπÖ Î∞è Î©îÌä∏Î¶≠"""
        operation_id = str(uuid.uuid4())
        start_time = time.time()

        self.logger.info(f"{operation}_started", operation_id=operation_id, **kwargs)

        try:
            yield operation_id
            duration = time.time() - start_time
            self.metrics.record_success(operation, duration)
            self.logger.info(f"{operation}_completed",
                           operation_id=operation_id, duration_ms=int(duration * 1000))
        except Exception as e:
            duration = time.time() - start_time
            self.metrics.record_error(operation, duration)
            self.logger.error(f"{operation}_failed",
                            operation_id=operation_id, error=str(e))
            raise
```

### 4. Î≤ÑÏ†Ñ Í¥ÄÎ¶¨ Ï†ÑÎûµ

MAJOR.MINOR.BUILD ÌòïÏãùÏúºÎ°ú ÏóÑÍ≤©Ìïú Î≤ÑÏ†Ñ Í¥ÄÎ¶¨:

```python
@dataclass
class SystemVersion:
    """ÏãúÏä§ÌÖú Î≤ÑÏ†Ñ Í¥ÄÎ¶¨"""
    major: int  # Breaking changes
    minor: int  # New features
    build: int  # Bug fixes

    def __str__(self) -> str:
        return f"{self.major}.{self.minor}.{self.build}"

    def is_compatible_with(self, other: 'SystemVersion') -> bool:
        """ÌïòÏúÑ Ìò∏ÌôòÏÑ± Í≤ÄÏÇ¨"""
        return self.major == other.major

# Î≤ÑÏ†Ñ Í∏∞Î∞ò ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
class VersionMigrator:
    def migrate_index(self, from_version: SystemVersion,
                     to_version: SystemVersion) -> MigrationResult:
        """Ïù∏Îç±Ïä§ Î≤ÑÏ†Ñ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò"""
        migrations = self.get_migrations_between(from_version, to_version)

        for migration in migrations:
            migration.apply()

        return MigrationResult.success()
```

---

> **@DATA:TAG-MODEL** ÌÉúÍ∑∏Î•º ÌÜµÌï¥ Ïù¥ Îç∞Ïù¥ÌÑ∞ Î™®Îç∏Ïù¥ SPEC-002 Íµ¨ÌòÑÏùò Í∏∞Î∞òÏù¥ Îê©ÎãàÎã§.
>
> **Îã§Ïùå Îã®Í≥Ñ**: `/moai:4-tasks SPEC-002`Î°ú TDD Í∏∞Î∞ò Íµ¨ÌòÑ ÏûëÏóÖ Î∂ÑÌï¥