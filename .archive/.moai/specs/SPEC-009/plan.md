# SPEC-009 구현 계획: TAG 시스템 SQLite 마이그레이션

**@CODE:IMPLEMENTATION-PLAN-001** ← 전체 계획  
**@CODE:MILESTONE-TRACKING-001** ← 마일스톤 추적  
**@CODE:RISK-MITIGATION-001** ← 위험 관리

---

## 개요

441개 TAG, 4,747줄, 136KB의 `tags.json` 파일을 SQLite 데이터베이스로 마이그레이션하여 **10배 성능 향상**을 달성하며, 기존 JSON API와 100% 호환성을 유지하는 점진적 마이그레이션 계획입니다.

### 주요 성과물
- **SQLite 데이터베이스 스키마**: tags, tag_references, schema_version 테이블
- **호호성 어댑터**: 기존 JSON API를 SQLite 백엔드로 투명 변환
- **마이그레이션 도구**: JSON ↔ SQLite 양방향 변환 도구
- **성능 벤치마크**: 전환 전후 성능 비교 도구

---

## Phase 1: 기반 인프라 구축

### @CODE:DATABASE-SCHEMA-001 SQLite 스키마 설계

**목표**: 성능 최적화된 데이터베이스 스키마 구축

**주요 작업**:
1. **테이블 설계**
   - `tags` 테이블: TAG 메타데이터 저장
   - `tag_references` 테이블: 파일 참조 정보
   - `schema_version` 테이블: 버전 관리

2. **인덱스 전략**
   - `tag_key`, `tag_type` 인덱스 (고속 검색)
   - `file_path`, `line_number` 인덱스 (참조 추적)
   - 복합 인덱스 최적화

3. **제약 조건**
   - UNIQUE 제약: 중복 TAG 방지
   - FOREIGN KEY: 참조 무결성
   - CASCADE DELETE: 참조 일관성

**예상 결과**: 3개 테이블, 6개 인덱스로 구성된 최적화된 스키마

### @CODE:DATABASE-MANAGER-001 데이터베이스 매니저 구현

**목표**: SQLite 데이터베이스 CRUD 작업 처리

**주요 작업**:
1. **TagDatabaseManager 클래스**
   - 연결 관리: 스레드 안전성
   - CRUD 작업: INSERT, SELECT, UPDATE, DELETE
   - 트랜잭션 처리: ACID 보장

2. **성능 최적화**
   - 배치 삽입: 대량 데이터 처리
   - 준비된 문: SQL 인젝션 방지
   - 연결 풀링: 성능 개선

3. **오류 처리**
   - 데이터베이스 잠금 상황
   - 디스크 공간 부족
   - 손상된 데이터베이스 복구

**예상 결과**: 안정적이고 고성능인 SQLite 인터페이스

**검증 포인트**: 간단한 CRUD 작업이 JSON 대비 5배 이상 빨라지는지 확인

---

## Phase 2: 호환성 어댑터 개발

### @CODE:API-COMPATIBILITY-001 JSON API 호환성 레이어

**목표**: 기존 JSON API와 100% 호환성 유지

**주요 작업**:
1. **TagIndexAdapter 클래스**
   - `get_tags()`: SQLite → JSON 포맷 변환
   - `add_tag()`: JSON 파라미터 → SQLite 삽입
   - `remove_tag()`: TAG 및 참조 일괄 삭제

2. **데이터 변환 로직**
   - SQLite 결과 → JSON 구조체
   - 타임스탬프 포맷 일치
   - 중첩된 참조 구조 재구성

3. **성능 최적화**
   - 캐싱 전략: 자주 사용되는 데이터
   - 지연 로딩: 필요할 때만 데이터 생성
   - 배치 처리: 여러 TAG 동시 처리

**예상 결과**: 기존 코드 변경 없이 투명한 SQLite 백엔드 전환

### @CODE:BACKWARD-COMPATIBILITY-001 이전 버전 호환성

**목표**: 기존 스크립트 및 도구 지원

**주요 작업**:
1. **기존 도구 호호성**
   - `validate_tags.py`: 기존 기능 유지
   - `/moai:3-sync`: 동일한 출력 포맷
   - TAG 검색/필터링 인터페이스

2. **설정 파일 처리**
   - 자동 감지: JSON vs SQLite 오토 전환
   - 설정 마이그레이션: 기존 설정 유지
   - 에러 핸들링: 꼭뿕한 예외 상황 대응

**예상 결과**: 모든 기존 스크립트가 변경 없이 동작

**검증 포인트**: `validate_tags.py` 실행 결과가 기존과 동일하게 출력되는지 확인

---

## Phase 3: 마이그레이션 도구 개발

### @CODE:MIGRATION-IMPLEMENTATION-001 양방향 변환 도구

**목표**: 안전하고 신뢰할 수 있는 데이터 변환 도구

**주요 작업**:
1. **TagMigrationTool 클래스**
   - `migrate_json_to_sqlite()`: JSON → SQLite 변환
   - `migrate_sqlite_to_json()`: SQLite → JSON 복원
   - `verify_migration()`: 변환 결과 검증

2. **데이터 무결성 보장**
   - 원자적 변환: 성공 또는 완전 롤백
   - 백업 생성: 변환 전 자동 백업
   - 검증 로직: 데이터 건전성 확인

3. **진행률 모니터링**
   - 실시간 진행 상황 표시
   - ETA 계산: 남은 시간 예측
   - 오류 리포팅: 상세한 오류 정보

**예상 결과**: 441개 TAG를 30초 이내에 안전하게 마이그레이션

### @CODE:ROLLBACK-STRATEGY-001 롤백 전략 구현

**목표**: 언제든지 이전 상태로 복원 가능

**주요 작업**:
1. **자동 백업 시스템**
   - 타임스탬프 기반 백업 파일
   - 마이그레이션 전후 스냅샷 생성
   - 백업 파일 무결성 검증

2. **원클릭 복원**
   - CLI 명령어: `moai-adk rollback --backup=<timestamp>`
   - 설정 파일 복원: 인덱스 경로 전환
   - 유효성 검사: 복원 전 백업 파일 검증

**예상 결과**: 10초 이내에 안전한 롤백 완료

**검증 포인트**: 마이그레이션 후 롤백 실행 시 완전한 JSON 복원

---

## Phase 4: 성능 최적화 및 벤치마크

### @CODE:PERFORMANCE-OPTIMIZATION-001 성능 최적화

**목표**: 10배 성능 향상 목표 달성

**주요 작업**:
1. **인덱스 전략 최적화**
   - 복합 인덱스: 다중 컴럼 인덱스 최적화
   - 부분 인덱스: WHERE 조건에 맞는 인덱스
   - 커버링 인뎁스: 모든 데이터를 인됁스에서 처리

2. **쿼리 최적화**
   - JOIN 최적화: 효율적인 테이블 결합
   - EXPLAIN QUERY PLAN: 실행 계획 분석
   - 준비된 문 캐싱: 반복 사용 쿼리 최적화

3. **메모리 관리**
   - 지연 로딩: 필요할 때만 데이터 로딩
   - 사이즈 제한: 거대한 결과집 분할 처리
   - 참조 계수: 연결 수 최소화

**예상 결과**: 1,000개 TAG 검색이 10ms 이내에 완료

### @CODE:PERFORMANCE-BENCHMARK-001 성능 비교 도구

**목표**: JSON vs SQLite 성능 차이 정량적 측정

**주요 작업**:
1. **TagPerformanceBenchmark 클래스**
   - `benchmark_search()`: 검색 성능 비교
   - `benchmark_insert()`: 삽입 성능 비교
   - `benchmark_memory_usage()`: 메모리 사용량 비교

2. **성능 측정 시나리오**
   - 소규모: 100개 TAG (현재 규모의 1/4)
   - 중규모: 1,000개 TAG (현재 규모의 2배)
   - 대규모: 10,000개 TAG (현재 규모의 20배)

3. **상세 보고서**
   - 실행 시간: 평균, 최대, 최소 시간
   - 리소스 사용량: CPU, 메모리, 디스크 I/O
   - 확장성 분석: 데이터 크기별 성능 변화

**예상 결과**: JSON 대비 10배 빠른 성능 입증

**검증 포인트**: 벤치마크 결과가 목표 성능 지표를 만족하는지 확인

---

## Phase 5: 통합 테스트 및 완성도 검증

### @TEST:INTEGRATION-TEST-001 전체 시스템 테스트

**목표**: 모든 컴포넌트 통합 동작 확인

**주요 작업**:
1. **마이그레이션 E2E 테스트**
   - JSON → SQLite → JSON 완전 라운드트립
   - 441개 실제 TAG 데이터 마이그레이션
   - 데이터 손실 0건, 변경 0건 확인

2. **호호성 테스트**
   - 기존 API 호출 시 동일한 결과
   - `validate_tags.py` 실행 결과 비교
   - `/moai:3-sync` 명령어 정상 동작

3. **예외 상황 테스트**
   - 데이터베이스 잠금 상황
   - 디스크 공간 부족 상황
   - 손상된 파일 복구 상황

**예상 결과**: 100% 통과율로 안정성 입증

### @CODE:DOCUMENTATION-001 사용자 문서 완성

**목표**: 사용자 기준 마이그레이션 가이드 제공

**주요 작업**:
1. **마이그레이션 가이드**
   - 단계별 마이그레이션 절차
   - 예상 소요 시간 및 준비 사항
   - 문제 해결 가이드 (FAQ)

2. **API 레퍼런스**
   - 새로운 SQLite 기반 API 설명
   - 기존 JSON API와의 차이점
   - 성능 최적화 팁

3. **롤백 및 대막성 가이드**
   - 롤백 실행 절차
   - 데이터 복구 시나리오
   - 마이그레이션 사전 준비

**예상 결과**: 사용자가 혹시 지원 없이도 마이그레이션 수행 가능

**검증 포인트**: 문서를 따라하여 새로운 사용자가 성공적으로 마이그레이션 완료

---

## 위험 관리 계획

### @CODE:RISK-MITIGATION-001 주요 위험 요소

**R1. 데이터 손실 위험**
- **위험**: 마이그레이션 중 TAG 데이터 손실
- **확률**: 낮음 (10%)
- **영향**: 매우 높음
- **대응**: 자동 백업 + 원자적 트랜잭션

**R2. 성능 목표 미달성**
- **위험**: 10배 성능 향상 목표 미달성
- **확률**: 중간 (30%)
- **영향**: 중간
- **대응**: 단계적 최적화 + 상세 벤치마크

**R3. 호환성 문제**
- **위험**: 기존 API와의 미묘한 차이점
- **확률**: 중간 (25%)
- **영향**: 높음
- **대응**: 광범위한 호환성 테스트 + Adapter 패턴

### @CODE:MILESTONE-TRACKING-001 성과 지표

**M1. Phase 1 완료** (기준자료)
- **지표**: SQLite 스키마 생성 + 기본 CRUD 작업
- **성공 기준**: 단순 삽입/검색이 JSON 대비 2배 이상 빠름

**M2. Phase 2 완료** (호환성 보장)
- **지표**: 기존 API 100% 호환성
- **성공 기준**: `validate_tags.py` 실행 결과 동일

**M3. Phase 3 완료** (마이그레이션 안정성)
- **지표**: 441개 TAG 마이그레이션 성공
- **성공 기준**: 마이그레이션 후 롤백 시 100% 동일한 데이터

**M4. Phase 4 완룼** (성능 목표)
- **지표**: 10배 성능 향상
- **성공 기준**: 1,000개 TAG 검색이 10ms 이내

**M5. Phase 5 완료** (전체 시스템 안정성)
- **지표**: 모든 테스트 통과 + 문서 완성
- **성공 기준**: 사용자가 문서만으로 마이그레이션 성공

---

## 추가 고려사항

### @DOC:EXTENSIBILITY-001 확장성 고려사항

1. **다중 프로젝트 지원**: 데이터베이스 분리 전략
2. **원격 데이터베이스 지원**: PostgreSQL, MySQL 확장 가능성
3. **실시간 동기화**: 여러 클라이언트 간 TAG 동기화

### @DOC:FUTURE-IMPROVEMENTS-001 버전 생각 개선사항

1. **전체 텍스트 검색**: FTS5 확장을 통한 고도화된 검색
2. **그래프 기반 TAG 추적**: TAG 간 종속성 매핑
3. **머신러닝 TAG 제안**: 유사 TAG 자동 제안 기능

---

**최종 목표**: 기존의 136KB JSON 파일을 고성능 SQLite 데이터베이스로 전환하여 10배 빠르고, 50% 적은 메모리를 사용하며, 기존 API와 100% 호환되는 TAG 시스템을 안전하게 구축하는 것입니다.